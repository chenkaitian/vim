// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.2.2.11 by WSRD Tencent.
// Generated from `Auth.jce'
// **********************************************************************

#ifndef __AUTH_H_
#define __AUTH_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
#include "jce/wup.h"
#include "servant/BaseF.h"

using namespace wup;
using namespace std;

#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace taf
{
    enum AUTH_STATE
    {
        AUTH_NONE = -127,
        AUTH_SUCC = 0,
        AUTH_WAIT_RSP = 127,
        AUTH_PROTO_ERR = -100,
        AUTH_WRONG_OBJ = -101,
        AUTH_WRONG_AK = -102,
        AUTH_WRONG_TIME = -103,
        AUTH_NOT_SUPPORT_ENC = -104,
        AUTH_DEC_FAIL = -105,
        AUTH_ERROR = -106,
    };
    inline string etos(const AUTH_STATE & e)
    {
        switch(e)
        {
            case AUTH_NONE: return "AUTH_NONE";
            case AUTH_SUCC: return "AUTH_SUCC";
            case AUTH_WAIT_RSP: return "AUTH_WAIT_RSP";
            case AUTH_PROTO_ERR: return "AUTH_PROTO_ERR";
            case AUTH_WRONG_OBJ: return "AUTH_WRONG_OBJ";
            case AUTH_WRONG_AK: return "AUTH_WRONG_AK";
            case AUTH_WRONG_TIME: return "AUTH_WRONG_TIME";
            case AUTH_NOT_SUPPORT_ENC: return "AUTH_NOT_SUPPORT_ENC";
            case AUTH_DEC_FAIL: return "AUTH_DEC_FAIL";
            case AUTH_ERROR: return "AUTH_ERROR";
            default: return "";
        }
    }
    inline int stoe(const string & s, AUTH_STATE & e)
    {
        if(s == "AUTH_NONE")  { e=AUTH_NONE; return 0;}
        if(s == "AUTH_SUCC")  { e=AUTH_SUCC; return 0;}
        if(s == "AUTH_WAIT_RSP")  { e=AUTH_WAIT_RSP; return 0;}
        if(s == "AUTH_PROTO_ERR")  { e=AUTH_PROTO_ERR; return 0;}
        if(s == "AUTH_WRONG_OBJ")  { e=AUTH_WRONG_OBJ; return 0;}
        if(s == "AUTH_WRONG_AK")  { e=AUTH_WRONG_AK; return 0;}
        if(s == "AUTH_WRONG_TIME")  { e=AUTH_WRONG_TIME; return 0;}
        if(s == "AUTH_NOT_SUPPORT_ENC")  { e=AUTH_NOT_SUPPORT_ENC; return 0;}
        if(s == "AUTH_DEC_FAIL")  { e=AUTH_DEC_FAIL; return 0;}
        if(s == "AUTH_ERROR")  { e=AUTH_ERROR; return 0;}

        return -1;
    }

    enum AUTH_TYPE
    {
        AUTH_TYPENONE = 0,
        AUTH_TYPELOCAL = 1,
        AUTH_TYPEREMOTE = 2,
    };
    inline string etos(const AUTH_TYPE & e)
    {
        switch(e)
        {
            case AUTH_TYPENONE: return "AUTH_TYPENONE";
            case AUTH_TYPELOCAL: return "AUTH_TYPELOCAL";
            case AUTH_TYPEREMOTE: return "AUTH_TYPEREMOTE";
            default: return "";
        }
    }
    inline int stoe(const string & s, AUTH_TYPE & e)
    {
        if(s == "AUTH_TYPENONE")  { e=AUTH_TYPENONE; return 0;}
        if(s == "AUTH_TYPELOCAL")  { e=AUTH_TYPELOCAL; return 0;}
        if(s == "AUTH_TYPEREMOTE")  { e=AUTH_TYPEREMOTE; return 0;}

        return -1;
    }

    struct BasicAuthInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.BasicAuthInfo";
        }
        static string MD5()
        {
            return "c73c13678f156f762d622e8672930c1d";
        }
        BasicAuthInfo()
        :sObjName(""),sAccessKey(""),sSecretKey(""),sHashSecretKey2(""),sUserData("")
        {
        }
        void resetDefautlt()
        {
            sObjName = "";
            sAccessKey = "";
            sSecretKey = "";
            sHashSecretKey2 = "";
            sUserData = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sObjName, 1);
            _os.write(sAccessKey, 2);
            _os.write(sSecretKey, 3);
            _os.write(sHashSecretKey2, 4);
            _os.write(sUserData, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sObjName, 1, false);
            _is.read(sAccessKey, 2, false);
            _is.read(sSecretKey, 3, false);
            _is.read(sHashSecretKey2, 4, false);
            _is.read(sUserData, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sObjName,"sObjName");
            _ds.display(sAccessKey,"sAccessKey");
            _ds.display(sSecretKey,"sSecretKey");
            _ds.display(sHashSecretKey2,"sHashSecretKey2");
            _ds.display(sUserData,"sUserData");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sObjName, true);
            _ds.displaySimple(sAccessKey, true);
            _ds.displaySimple(sSecretKey, true);
            _ds.displaySimple(sHashSecretKey2, true);
            _ds.displaySimple(sUserData, false);
            return _os;
        }
    public:
        std::string sObjName;
        std::string sAccessKey;
        std::string sSecretKey;
        std::string sHashSecretKey2;
        std::string sUserData;
    };
    inline bool operator==(const BasicAuthInfo&l, const BasicAuthInfo&r)
    {
        return l.sObjName == r.sObjName && l.sAccessKey == r.sAccessKey && l.sSecretKey == r.sSecretKey && l.sHashSecretKey2 == r.sHashSecretKey2 && l.sUserData == r.sUserData;
    }
    inline bool operator!=(const BasicAuthInfo&l, const BasicAuthInfo&r)
    {
        return !(l == r);
    }

    struct BasicAuthPackage : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.BasicAuthPackage";
        }
        static string MD5()
        {
            return "96c36c87918dd066bb07a1deaafdecf3";
        }
        BasicAuthPackage()
        :sObjName(""),sAccessKey(""),iTime(0),sHashMethod("sha1"),sSignature("")
        {
        }
        void resetDefautlt()
        {
            sObjName = "";
            sAccessKey = "";
            iTime = 0;
            sHashMethod = "sha1";
            sSignature = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sObjName, 1);
            _os.write(sAccessKey, 2);
            _os.write(iTime, 3);
            _os.write(sHashMethod, 4);
            _os.write(sSignature, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sObjName, 1, true);
            _is.read(sAccessKey, 2, true);
            _is.read(iTime, 3, true);
            _is.read(sHashMethod, 4, false);
            _is.read(sSignature, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sObjName,"sObjName");
            _ds.display(sAccessKey,"sAccessKey");
            _ds.display(iTime,"iTime");
            _ds.display(sHashMethod,"sHashMethod");
            _ds.display(sSignature,"sSignature");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sObjName, true);
            _ds.displaySimple(sAccessKey, true);
            _ds.displaySimple(iTime, true);
            _ds.displaySimple(sHashMethod, true);
            _ds.displaySimple(sSignature, false);
            return _os;
        }
    public:
        std::string sObjName;
        std::string sAccessKey;
        taf::Int64 iTime;
        std::string sHashMethod;
        std::string sSignature;
    };
    inline bool operator==(const BasicAuthPackage&l, const BasicAuthPackage&r)
    {
        return l.sObjName == r.sObjName && l.sAccessKey == r.sAccessKey && l.iTime == r.iTime && l.sHashMethod == r.sHashMethod && l.sSignature == r.sSignature;
    }
    inline bool operator!=(const BasicAuthPackage&l, const BasicAuthPackage&r)
    {
        return !(l == r);
    }

    struct AuthRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.AuthRequest";
        }
        static string MD5()
        {
            return "580d13c7662ac1eb948bc31ca7e73e2c";
        }
        AuthRequest()
        :sObjName(""),sRequest(""),iFd(0),iUid(0)
        {
        }
        void resetDefautlt()
        {
            sObjName = "";
            sRequest = "";
            iFd = 0;
            iUid = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sObjName, 1);
            _os.write(sRequest, 2);
            _os.write(iFd, 3);
            _os.write(iUid, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sObjName, 1, true);
            _is.read(sRequest, 2, true);
            _is.read(iFd, 3, true);
            _is.read(iUid, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sObjName,"sObjName");
            _ds.display(sRequest,"sRequest");
            _ds.display(iFd,"iFd");
            _ds.display(iUid,"iUid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sObjName, true);
            _ds.displaySimple(sRequest, true);
            _ds.displaySimple(iFd, true);
            _ds.displaySimple(iUid, false);
            return _os;
        }
    public:
        std::string sObjName;
        std::string sRequest;
        taf::Int32 iFd;
        taf::Int64 iUid;
    };
    inline bool operator==(const AuthRequest&l, const AuthRequest&r)
    {
        return l.sObjName == r.sObjName && l.sRequest == r.sRequest && l.iFd == r.iFd && l.iUid == r.iUid;
    }
    inline bool operator!=(const AuthRequest&l, const AuthRequest&r)
    {
        return !(l == r);
    }

    struct AuthResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.AuthResponse";
        }
        static string MD5()
        {
            return "28ce23c13b8514800d554de099957a7d";
        }
        AuthResponse()
        :iState(0),iFd(0),iUid(0)
        {
        }
        void resetDefautlt()
        {
            iState = 0;
            iFd = 0;
            iUid = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iState, 1);
            _os.write(iFd, 2);
            _os.write(iUid, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iState, 1, true);
            _is.read(iFd, 2, true);
            _is.read(iUid, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iState,"iState");
            _ds.display(iFd,"iFd");
            _ds.display(iUid,"iUid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iState, true);
            _ds.displaySimple(iFd, true);
            _ds.displaySimple(iUid, false);
            return _os;
        }
    public:
        taf::Int32 iState;
        taf::Int32 iFd;
        taf::Int64 iUid;
    };
    inline bool operator==(const AuthResponse&l, const AuthResponse&r)
    {
        return l.iState == r.iState && l.iFd == r.iFd && l.iUid == r.iUid;
    }
    inline bool operator!=(const AuthResponse&l, const AuthResponse&r)
    {
        return !(l == r);
    }

    /* callback of async proxy for client */
    class AuthPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~AuthPrxCallback(){}
        virtual void callback_authProcess(const taf::AuthResponse& ret)
        { throw std::runtime_error("callback_authProcess() override incorrect."); }
        virtual void callback_authProcess_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_authProcess_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const;

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<AuthPrxCallback> AuthPrxCallbackPtr;

    /* callback of promise async proxy for client */
    class AuthPrxCallbackPromise: public taf::ServantProxyCallback
    {
    public:
        virtual ~AuthPrxCallbackPromise(){}
    public:
        struct PromiseauthProcess: virtual public TC_HandleBase
        {
        public:
            taf::AuthResponse _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< AuthPrxCallbackPromise::PromiseauthProcess > PromiseauthProcessPtr;

        AuthPrxCallbackPromise(const promise::Promise< AuthPrxCallbackPromise::PromiseauthProcessPtr > &promise)
        : _promise_authProcess(promise)
        {}
        
        virtual void callback_authProcess(const AuthPrxCallbackPromise::PromiseauthProcessPtr &ptr)
        {
            _promise_authProcess.setValue(ptr);
        }
        virtual void callback_authProcess_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:authProcess_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_authProcess.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< AuthPrxCallbackPromise::PromiseauthProcessPtr > _promise_authProcess;

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<AuthPrxCallbackPromise> AuthPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class AuthCoroPrxCallback: public AuthPrxCallback
    {
    public:
        virtual ~AuthCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef taf::TC_AutoPtr<AuthCoroPrxCallback> AuthCoroPrxCallbackPtr;

    /* proxy for client */
    class AuthProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        taf::AuthResponse authProcess(const taf::AuthRequest & request,const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_authProcess(AuthPrxCallbackPtr callback,const taf::AuthRequest & request,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< AuthPrxCallbackPromise::PromiseauthProcessPtr > promise_async_authProcess(const taf::AuthRequest & request,const map<string, string> &context = TAF_CONTEXT());
        void coro_authProcess(AuthCoroPrxCallbackPtr callback,const taf::AuthRequest & request,const map<string, string> &context = TAF_CONTEXT());

        AuthProxy* taf_hash(int64_t key);
        AuthProxy* taf_consistent_hash(int64_t key);
        AuthProxy* taf_set_timeout(int msecond);
        AuthProxy* taf_loaded();
    };
    typedef taf::TC_AutoPtr<AuthProxy> AuthPrx;

    /* servant for server */
    class Auth : public taf::Servant
    {
    public:
        virtual ~Auth(){}
        virtual taf::AuthResponse authProcess(const taf::AuthRequest & request,taf::JceCurrentPtr current) = 0;
        static void async_response_authProcess(taf::JceCurrentPtr current, const taf::AuthResponse &_ret);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };

    inline taf::AuthResponse AuthProxy::authProcess(const taf::AuthRequest &request, const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(request, 1);
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"authProcess", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::AuthResponse _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    inline void Auth::async_response_authProcess(taf::JceCurrentPtr current, const taf::AuthResponse &_ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    inline void AuthProxy::async_authProcess(AuthPrxCallbackPtr callback,const taf::AuthRequest &request,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(request, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"authProcess", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    inline promise::Future< AuthPrxCallbackPromise::PromiseauthProcessPtr > AuthProxy::promise_async_authProcess(const taf::AuthRequest &request,const map<string, string>& context)
    {
        promise::Promise< AuthPrxCallbackPromise::PromiseauthProcessPtr > promise;
        AuthPrxCallbackPromisePtr callback = new AuthPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(request, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"authProcess", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    inline void AuthProxy::coro_authProcess(AuthCoroPrxCallbackPtr callback,const taf::AuthRequest &request,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(request, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"authProcess", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    inline AuthProxy* AuthProxy::taf_hash(int64_t key)
    {
        return (AuthProxy*)ServantProxy::taf_hash(key);
    }

    inline AuthProxy* AuthProxy::taf_consistent_hash(int64_t key)
    {
        return (AuthProxy*)ServantProxy::taf_consistent_hash(key);
    }

    inline AuthProxy* AuthProxy::taf_set_timeout(int msecond)
    {
        return (AuthProxy*)ServantProxy::taf_set_timeout(msecond);
    }

    inline AuthProxy* AuthProxy::taf_loaded()
    {
        return (AuthProxy*)ServantProxy::taf_loaded();
    }

    static ::std::string __taf__Auth_all[]=
    {
        "authProcess"
    };

    inline const map<std::string, std::string> & AuthPrxCallback::getResponseContext() const
    {
        CallbackThreadData * pCbtd = CallbackThreadData::getData();
        assert(pCbtd != NULL);

        if(!pCbtd->getContextValid())
        {
            throw TC_Exception("cann't get response context");
        }
        return pCbtd->getResponseContext();
    }

    inline int AuthPrxCallback::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__taf__Auth_all, __taf__Auth_all+1, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __taf__Auth_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_authProcess_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::AuthResponse _ret;
                _is.read(_ret, 0, true);

                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_authProcess(_ret);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    inline int AuthPrxCallbackPromise::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__taf__Auth_all, __taf__Auth_all+1, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __taf__Auth_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_authProcess_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                AuthPrxCallbackPromise::PromiseauthProcessPtr ptr = new AuthPrxCallbackPromise::PromiseauthProcess();

                _is.read(ptr->_ret, 0, true);


                ptr->_mRspContext = msg->response.context;

                callback_authProcess(ptr);

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    inline int AuthCoroPrxCallback::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__taf__Auth_all, __taf__Auth_all+1, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __taf__Auth_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_authProcess_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::AuthResponse _ret;
                _is.read(_ret, 0, true);

                setResponseContext(msg->response.context);

                callback_authProcess(_ret);

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    inline int Auth::onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer)
    {
        pair<string*, string*> r = equal_range(__taf__Auth_all, __taf__Auth_all+1, _current->getFuncName());
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __taf__Auth_all)
        {
            case 0:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                taf::AuthRequest request;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("request", request);
                }
                else
                {
                    _is.read(request, 1, true);
                }
                taf::AuthResponse _ret = authProcess(request, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

} // end namespace taf

#define taf_BasicAuthInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.sObjName,b.sObjName);jce_copy_struct(a.sAccessKey,b.sAccessKey);jce_copy_struct(a.sSecretKey,b.sSecretKey);jce_copy_struct(a.sHashSecretKey2,b.sHashSecretKey2);jce_copy_struct(a.sUserData,b.sUserData);

#define taf_BasicAuthPackage_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.sObjName,b.sObjName);jce_copy_struct(a.sAccessKey,b.sAccessKey);jce_copy_struct(a.iTime,b.iTime);jce_copy_struct(a.sHashMethod,b.sHashMethod);jce_copy_struct(a.sSignature,b.sSignature);

#define taf_AuthRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.sObjName,b.sObjName);jce_copy_struct(a.sRequest,b.sRequest);jce_copy_struct(a.iFd,b.iFd);jce_copy_struct(a.iUid,b.iUid);

#define taf_AuthResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iState,b.iState);jce_copy_struct(a.iFd,b.iFd);jce_copy_struct(a.iUid,b.iUid);


#endif

