// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.2.2.11 by WSRD Tencent.
// Generated from `EndpointF.jce'
// **********************************************************************

#ifndef __ENDPOINTF_H_
#define __ENDPOINTF_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
#include "jce/wup.h"
#include "servant/BaseF.h"

using namespace wup;
using namespace std;



namespace taf
{
    struct EndpointF : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.EndpointF";
        }
        static string MD5()
        {
            return "2a48af46bee37bfa8472e62dfbf0202e";
        }
        EndpointF()
        :host(""),port(0),timeout(0),istcp(0),grid(0),groupworkid(0),grouprealid(0),setId(""),qos(0),bakFlag(0),gridFlag(0),weight(0),weightType(0),cpuload(0),sampletime(0),containerName(""),grayFlag(0)
        {
        }
        void resetDefautlt()
        {
            host = "";
            port = 0;
            timeout = 0;
            istcp = 0;
            grid = 0;
            groupworkid = 0;
            grouprealid = 0;
            setId = "";
            qos = 0;
            bakFlag = 0;
            gridFlag = 0;
            weight = 0;
            weightType = 0;
            cpuload = 0;
            sampletime = 0;
            containerName = "";
            grayFlag = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(host, 0);
            _os.write(port, 1);
            _os.write(timeout, 2);
            _os.write(istcp, 3);
            _os.write(grid, 4);
            _os.write(groupworkid, 5);
            _os.write(grouprealid, 6);
            _os.write(setId, 7);
            _os.write(qos, 8);
            _os.write(bakFlag, 9);
            _os.write(gridFlag, 10);
            _os.write(weight, 11);
            _os.write(weightType, 12);
            _os.write(cpuload, 13);
            _os.write(sampletime, 14);
            _os.write(containerName, 15);
            _os.write(grayFlag, 16);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(host, 0, true);
            _is.read(port, 1, true);
            _is.read(timeout, 2, true);
            _is.read(istcp, 3, true);
            _is.read(grid, 4, true);
            _is.read(groupworkid, 5, false);
            _is.read(grouprealid, 6, false);
            _is.read(setId, 7, false);
            _is.read(qos, 8, false);
            _is.read(bakFlag, 9, false);
            _is.read(gridFlag, 10, false);
            _is.read(weight, 11, false);
            _is.read(weightType, 12, false);
            _is.read(cpuload, 13, false);
            _is.read(sampletime, 14, false);
            _is.read(containerName, 15, false);
            _is.read(grayFlag, 16, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(host,"host");
            _ds.display(port,"port");
            _ds.display(timeout,"timeout");
            _ds.display(istcp,"istcp");
            _ds.display(grid,"grid");
            _ds.display(groupworkid,"groupworkid");
            _ds.display(grouprealid,"grouprealid");
            _ds.display(setId,"setId");
            _ds.display(qos,"qos");
            _ds.display(bakFlag,"bakFlag");
            _ds.display(gridFlag,"gridFlag");
            _ds.display(weight,"weight");
            _ds.display(weightType,"weightType");
            _ds.display(cpuload,"cpuload");
            _ds.display(sampletime,"sampletime");
            _ds.display(containerName,"containerName");
            _ds.display(grayFlag,"grayFlag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(host, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(timeout, true);
            _ds.displaySimple(istcp, true);
            _ds.displaySimple(grid, true);
            _ds.displaySimple(groupworkid, true);
            _ds.displaySimple(grouprealid, true);
            _ds.displaySimple(setId, true);
            _ds.displaySimple(qos, true);
            _ds.displaySimple(bakFlag, true);
            _ds.displaySimple(gridFlag, true);
            _ds.displaySimple(weight, true);
            _ds.displaySimple(weightType, true);
            _ds.displaySimple(cpuload, true);
            _ds.displaySimple(sampletime, true);
            _ds.displaySimple(containerName, true);
            _ds.displaySimple(grayFlag, false);
            return _os;
        }
    public:
        std::string host;
        taf::Int32 port;
        taf::Int32 timeout;
        taf::Int32 istcp;
        taf::Int32 grid;
        taf::Int32 groupworkid;
        taf::Int32 grouprealid;
        std::string setId;
        taf::Int32 qos;
        taf::Int32 bakFlag;
        taf::Int32 gridFlag;
        taf::Int32 weight;
        taf::Int32 weightType;
        taf::Int32 cpuload;
        taf::Int64 sampletime;
        std::string containerName;
        taf::Int32 grayFlag;
    };
    inline bool operator==(const EndpointF&l, const EndpointF&r)
    {
        return l.host == r.host && l.port == r.port && l.timeout == r.timeout && l.istcp == r.istcp && l.grid == r.grid && l.groupworkid == r.groupworkid && l.grouprealid == r.grouprealid && l.setId == r.setId && l.qos == r.qos && l.bakFlag == r.bakFlag && l.gridFlag == r.gridFlag && l.weight == r.weight && l.weightType == r.weightType && l.cpuload == r.cpuload && l.sampletime == r.sampletime && l.containerName == r.containerName && l.grayFlag == r.grayFlag;
    }
    inline bool operator!=(const EndpointF&l, const EndpointF&r)
    {
        return !(l == r);
    }
    inline bool operator<(const EndpointF&l, const EndpointF&r)
    {
        if(l.host != r.host)  return (l.host < r.host);
        if(l.port != r.port)  return (l.port < r.port);
        if(l.timeout != r.timeout)  return (l.timeout < r.timeout);
        if(l.istcp != r.istcp)  return (l.istcp < r.istcp);
        if(l.grid != r.grid)  return (l.grid < r.grid);
        if(l.qos != r.qos)  return (l.qos < r.qos);
        if(l.gridFlag != r.gridFlag)  return (l.gridFlag < r.gridFlag);
        if(l.weight != r.weight)  return (l.weight < r.weight);
        if(l.weightType != r.weightType)  return (l.weightType < r.weightType);
        return false;
    }
    inline bool operator<=(const EndpointF&l, const EndpointF&r)
    {
        return !(r < l);
    }
    inline bool operator>(const EndpointF&l, const EndpointF&r)
    {
        return r < l;
    }
    inline bool operator>=(const EndpointF&l, const EndpointF&r)
    {
        return !(l < r);
    }


} // end namespace taf

#define taf_EndpointF_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.host,b.host);jce_copy_struct(a.port,b.port);jce_copy_struct(a.timeout,b.timeout);jce_copy_struct(a.istcp,b.istcp);jce_copy_struct(a.grid,b.grid);jce_copy_struct(a.groupworkid,b.groupworkid);jce_copy_struct(a.grouprealid,b.grouprealid);jce_copy_struct(a.setId,b.setId);jce_copy_struct(a.qos,b.qos);jce_copy_struct(a.bakFlag,b.bakFlag);jce_copy_struct(a.gridFlag,b.gridFlag);jce_copy_struct(a.weight,b.weight);jce_copy_struct(a.weightType,b.weightType);jce_copy_struct(a.cpuload,b.cpuload);jce_copy_struct(a.sampletime,b.sampletime);jce_copy_struct(a.containerName,b.containerName);jce_copy_struct(a.grayFlag,b.grayFlag);


#endif

