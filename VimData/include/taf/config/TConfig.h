// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.2.2.11 by WSRD Tencent.
// Generated from `TConfig.jce'
// **********************************************************************

#ifndef __TCONFIG_H_
#define __TCONFIG_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
#include "jce/wup.h"
#include "servant/BaseF.h"

using namespace wup;
using namespace std;

#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace TConf
{
    enum ConfigType
    {
        KV,
        SELFDEF,
    };
    inline string etos(const ConfigType & e)
    {
        switch(e)
        {
            case KV: return "KV";
            case SELFDEF: return "SELFDEF";
            default: return "";
        }
    }
    inline int stoe(const string & s, ConfigType & e)
    {
        if(s == "KV")  { e=KV; return 0;}
        if(s == "SELFDEF")  { e=SELFDEF; return 0;}

        return -1;
    }

    struct ConfReqListInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TConf.ConfReqListInfo";
        }
        static string MD5()
        {
            return "f8dec146f8963bc45c2842ea6f1f4b4f";
        }
        ConfReqListInfo()
        :configType(TConf::KV),fileName(""),md5("")
        {
        }
        void resetDefautlt()
        {
            fileName = "";
            md5 = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write((taf::Int32)configType, 0);
            _os.write(fileName, 1);
            _os.write(md5, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            taf::Int32 eTemp0 = TConf::KV;
            _is.read(eTemp0, 0, false);
            configType = (TConf::ConfigType)eTemp0;
            _is.read(fileName, 1, false);
            _is.read(md5, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display((taf::Int32)configType,"configType");
            _ds.display(fileName,"fileName");
            _ds.display(md5,"md5");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple((taf::Int32)configType, true);
            _ds.displaySimple(fileName, true);
            _ds.displaySimple(md5, false);
            return _os;
        }
    public:
        TConf::ConfigType configType;
        std::string fileName;
        std::string md5;
    };
    inline bool operator==(const ConfReqListInfo&l, const ConfReqListInfo&r)
    {
        return l.configType == r.configType && l.fileName == r.fileName && l.md5 == r.md5;
    }
    inline bool operator!=(const ConfReqListInfo&l, const ConfReqListInfo&r)
    {
        return !(l == r);
    }

    struct ConfReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TConf.ConfReq";
        }
        static string MD5()
        {
            return "78281bcdf2372fbd59f9ce0431931cae";
        }
        ConfReq()
        :appid(""),ns("DEFAULT_NS"),host(""),setname(""),containername(""),apiVersion("")
        {
        }
        void resetDefautlt()
        {
            appid = "";
            ns = "DEFAULT_NS";
            host = "";
            setname = "";
            containername = "";
            apiVersion = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(appid, 0);
            _os.write(ns, 1);
            _os.write(host, 2);
            _os.write(setname, 3);
            _os.write(containername, 4);
            _os.write(vConfInfoList, 5);
            _os.write(apiVersion, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appid, 0, true);
            _is.read(ns, 1, false);
            _is.read(host, 2, false);
            _is.read(setname, 3, false);
            _is.read(containername, 4, false);
            _is.read(vConfInfoList, 5, false);
            _is.read(apiVersion, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(appid,"appid");
            _ds.display(ns,"ns");
            _ds.display(host,"host");
            _ds.display(setname,"setname");
            _ds.display(containername,"containername");
            _ds.display(vConfInfoList,"vConfInfoList");
            _ds.display(apiVersion,"apiVersion");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(appid, true);
            _ds.displaySimple(ns, true);
            _ds.displaySimple(host, true);
            _ds.displaySimple(setname, true);
            _ds.displaySimple(containername, true);
            _ds.displaySimple(vConfInfoList, true);
            _ds.displaySimple(apiVersion, false);
            return _os;
        }
    public:
        std::string appid;
        std::string ns;
        std::string host;
        std::string setname;
        std::string containername;
        vector<TConf::ConfReqListInfo> vConfInfoList;
        std::string apiVersion;
    };
    inline bool operator==(const ConfReq&l, const ConfReq&r)
    {
        return l.appid == r.appid && l.ns == r.ns && l.host == r.host && l.setname == r.setname && l.containername == r.containername && l.vConfInfoList == r.vConfInfoList && l.apiVersion == r.apiVersion;
    }
    inline bool operator!=(const ConfReq&l, const ConfReq&r)
    {
        return !(l == r);
    }

    struct ConfRspInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TConf.ConfRspInfo";
        }
        static string MD5()
        {
            return "3b69e48bde557e70b6baafd5b51d64de";
        }
        ConfRspInfo()
        :configType(TConf::KV),fileName(""),fileContent(""),md5(""),updated(false)
        {
        }
        void resetDefautlt()
        {
            fileName = "";
            fileContent = "";
            md5 = "";
            updated = false;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write((taf::Int32)configType, 0);
            _os.write(fileName, 1);
            _os.write(fileContent, 2);
            _os.write(md5, 3);
            _os.write(updated, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            taf::Int32 eTemp0 = TConf::KV;
            _is.read(eTemp0, 0, false);
            configType = (TConf::ConfigType)eTemp0;
            _is.read(fileName, 1, false);
            _is.read(fileContent, 2, false);
            _is.read(md5, 3, false);
            _is.read(updated, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display((taf::Int32)configType,"configType");
            _ds.display(fileName,"fileName");
            _ds.display(fileContent,"fileContent");
            _ds.display(md5,"md5");
            _ds.display(updated,"updated");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple((taf::Int32)configType, true);
            _ds.displaySimple(fileName, true);
            _ds.displaySimple(fileContent, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(updated, false);
            return _os;
        }
    public:
        TConf::ConfigType configType;
        std::string fileName;
        std::string fileContent;
        std::string md5;
        taf::Bool updated;
    };
    inline bool operator==(const ConfRspInfo&l, const ConfRspInfo&r)
    {
        return l.configType == r.configType && l.fileName == r.fileName && l.fileContent == r.fileContent && l.md5 == r.md5 && l.updated == r.updated;
    }
    inline bool operator!=(const ConfRspInfo&l, const ConfRspInfo&r)
    {
        return !(l == r);
    }

    struct ConfRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TConf.ConfRsp";
        }
        static string MD5()
        {
            return "35eb55d467c3c866d4b40bb652cfeddf";
        }
        ConfRsp()
        :appid(""),refreshInterval(15)
        {
        }
        void resetDefautlt()
        {
            appid = "";
            refreshInterval = 15;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(appid, 0);
            _os.write(vConfInfoList, 1);
            _os.write(refreshInterval, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appid, 0, true);
            _is.read(vConfInfoList, 1, false);
            _is.read(refreshInterval, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(appid,"appid");
            _ds.display(vConfInfoList,"vConfInfoList");
            _ds.display(refreshInterval,"refreshInterval");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(appid, true);
            _ds.displaySimple(vConfInfoList, true);
            _ds.displaySimple(refreshInterval, false);
            return _os;
        }
    public:
        std::string appid;
        vector<TConf::ConfRspInfo> vConfInfoList;
        taf::Int32 refreshInterval;
    };
    inline bool operator==(const ConfRsp&l, const ConfRsp&r)
    {
        return l.appid == r.appid && l.vConfInfoList == r.vConfInfoList && l.refreshInterval == r.refreshInterval;
    }
    inline bool operator!=(const ConfRsp&l, const ConfRsp&r)
    {
        return !(l == r);
    }

    struct PublicConfReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TConf.PublicConfReq";
        }
        static string MD5()
        {
            return "fa14ddb17f43e830b08715bdae20e456";
        }
        PublicConfReq()
        :ns("DEFAULT_NS"),setname(""),apiVersion("")
        {
        }
        void resetDefautlt()
        {
            ns = "DEFAULT_NS";
            setname = "";
            apiVersion = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ns, 1);
            _os.write(setname, 2);
            _os.write(vConfInfoList, 3);
            _os.write(apiVersion, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ns, 1, true);
            _is.read(setname, 2, false);
            _is.read(vConfInfoList, 3, false);
            _is.read(apiVersion, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ns,"ns");
            _ds.display(setname,"setname");
            _ds.display(vConfInfoList,"vConfInfoList");
            _ds.display(apiVersion,"apiVersion");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ns, true);
            _ds.displaySimple(setname, true);
            _ds.displaySimple(vConfInfoList, true);
            _ds.displaySimple(apiVersion, false);
            return _os;
        }
    public:
        std::string ns;
        std::string setname;
        vector<TConf::ConfReqListInfo> vConfInfoList;
        std::string apiVersion;
    };
    inline bool operator==(const PublicConfReq&l, const PublicConfReq&r)
    {
        return l.ns == r.ns && l.setname == r.setname && l.vConfInfoList == r.vConfInfoList && l.apiVersion == r.apiVersion;
    }
    inline bool operator!=(const PublicConfReq&l, const PublicConfReq&r)
    {
        return !(l == r);
    }

    struct PublicConfRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TConf.PublicConfRsp";
        }
        static string MD5()
        {
            return "9860c823c630309d304341399761726a";
        }
        PublicConfRsp()
        :ns("DEFAULT_NS")
        {
        }
        void resetDefautlt()
        {
            ns = "DEFAULT_NS";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ns, 0);
            _os.write(vConfInfoList, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ns, 0, false);
            _is.read(vConfInfoList, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ns,"ns");
            _ds.display(vConfInfoList,"vConfInfoList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ns, true);
            _ds.displaySimple(vConfInfoList, false);
            return _os;
        }
    public:
        std::string ns;
        vector<TConf::ConfRspInfo> vConfInfoList;
    };
    inline bool operator==(const PublicConfRsp&l, const PublicConfRsp&r)
    {
        return l.ns == r.ns && l.vConfInfoList == r.vConfInfoList;
    }
    inline bool operator!=(const PublicConfRsp&l, const PublicConfRsp&r)
    {
        return !(l == r);
    }

    /* callback of async proxy for client */
    class ConfigCenterPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~ConfigCenterPrxCallback(){}
        virtual void callback_getConfInfo(taf::Int32 ret,  const TConf::ConfRsp& rsp)
        { throw std::runtime_error("callback_getConfInfo() override incorrect."); }
        virtual void callback_getConfInfo_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getConfInfo_exception() override incorrect."); }

        virtual void callback_getConfFileList(taf::Int32 ret,  const vector<std::string>& vf)
        { throw std::runtime_error("callback_getConfFileList() override incorrect."); }
        virtual void callback_getConfFileList_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getConfFileList_exception() override incorrect."); }

        virtual void callback_getPublicConf(taf::Int32 ret,  const TConf::PublicConfRsp& rsp)
        { throw std::runtime_error("callback_getPublicConf() override incorrect."); }
        virtual void callback_getPublicConf_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getPublicConf_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const;

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<ConfigCenterPrxCallback> ConfigCenterPrxCallbackPtr;

    /* callback of promise async proxy for client */
    class ConfigCenterPrxCallbackPromise: public taf::ServantProxyCallback
    {
    public:
        virtual ~ConfigCenterPrxCallbackPromise(){}
    public:
        struct PromisegetConfInfo: virtual public TC_HandleBase
        {
        public:
            taf::Int32 _ret;
            TConf::ConfRsp rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< ConfigCenterPrxCallbackPromise::PromisegetConfInfo > PromisegetConfInfoPtr;

        ConfigCenterPrxCallbackPromise(const promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetConfInfoPtr > &promise)
        : _promise_getConfInfo(promise)
        {}
        
        virtual void callback_getConfInfo(const ConfigCenterPrxCallbackPromise::PromisegetConfInfoPtr &ptr)
        {
            _promise_getConfInfo.setValue(ptr);
        }
        virtual void callback_getConfInfo_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:getConfInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getConfInfo.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetConfInfoPtr > _promise_getConfInfo;

    public:
        struct PromisegetConfFileList: virtual public TC_HandleBase
        {
        public:
            taf::Int32 _ret;
            vector<std::string> vf;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< ConfigCenterPrxCallbackPromise::PromisegetConfFileList > PromisegetConfFileListPtr;

        ConfigCenterPrxCallbackPromise(const promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetConfFileListPtr > &promise)
        : _promise_getConfFileList(promise)
        {}
        
        virtual void callback_getConfFileList(const ConfigCenterPrxCallbackPromise::PromisegetConfFileListPtr &ptr)
        {
            _promise_getConfFileList.setValue(ptr);
        }
        virtual void callback_getConfFileList_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:getConfFileList_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getConfFileList.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetConfFileListPtr > _promise_getConfFileList;

    public:
        struct PromisegetPublicConf: virtual public TC_HandleBase
        {
        public:
            taf::Int32 _ret;
            TConf::PublicConfRsp rsp;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< ConfigCenterPrxCallbackPromise::PromisegetPublicConf > PromisegetPublicConfPtr;

        ConfigCenterPrxCallbackPromise(const promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetPublicConfPtr > &promise)
        : _promise_getPublicConf(promise)
        {}
        
        virtual void callback_getPublicConf(const ConfigCenterPrxCallbackPromise::PromisegetPublicConfPtr &ptr)
        {
            _promise_getPublicConf.setValue(ptr);
        }
        virtual void callback_getPublicConf_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:getPublicConf_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getPublicConf.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetPublicConfPtr > _promise_getPublicConf;

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<ConfigCenterPrxCallbackPromise> ConfigCenterPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class ConfigCenterCoroPrxCallback: public ConfigCenterPrxCallback
    {
    public:
        virtual ~ConfigCenterCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef taf::TC_AutoPtr<ConfigCenterCoroPrxCallback> ConfigCenterCoroPrxCallbackPtr;

    /* proxy for client */
    class ConfigCenterProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        taf::Int32 getConfInfo(const TConf::ConfReq & req,TConf::ConfRsp &rsp,const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_getConfInfo(ConfigCenterPrxCallbackPtr callback,const TConf::ConfReq & req,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< ConfigCenterPrxCallbackPromise::PromisegetConfInfoPtr > promise_async_getConfInfo(const TConf::ConfReq & req,const map<string, string> &context = TAF_CONTEXT());
        void coro_getConfInfo(ConfigCenterCoroPrxCallbackPtr callback,const TConf::ConfReq & req,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 getConfFileList(const TConf::ConfReq & req,vector<std::string> &vf,const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_getConfFileList(ConfigCenterPrxCallbackPtr callback,const TConf::ConfReq & req,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< ConfigCenterPrxCallbackPromise::PromisegetConfFileListPtr > promise_async_getConfFileList(const TConf::ConfReq & req,const map<string, string> &context = TAF_CONTEXT());
        void coro_getConfFileList(ConfigCenterCoroPrxCallbackPtr callback,const TConf::ConfReq & req,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 getPublicConf(const TConf::PublicConfReq & req,TConf::PublicConfRsp &rsp,const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_getPublicConf(ConfigCenterPrxCallbackPtr callback,const TConf::PublicConfReq & req,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< ConfigCenterPrxCallbackPromise::PromisegetPublicConfPtr > promise_async_getPublicConf(const TConf::PublicConfReq & req,const map<string, string> &context = TAF_CONTEXT());
        void coro_getPublicConf(ConfigCenterCoroPrxCallbackPtr callback,const TConf::PublicConfReq & req,const map<string, string> &context = TAF_CONTEXT());

        ConfigCenterProxy* taf_hash(int64_t key);
        ConfigCenterProxy* taf_consistent_hash(int64_t key);
        ConfigCenterProxy* taf_set_timeout(int msecond);
        ConfigCenterProxy* taf_loaded();
    };
    typedef taf::TC_AutoPtr<ConfigCenterProxy> ConfigCenterPrx;

    /* servant for server */
    class ConfigCenter : public taf::Servant
    {
    public:
        virtual ~ConfigCenter(){}
        virtual taf::Int32 getConfInfo(const TConf::ConfReq & req,TConf::ConfRsp &rsp,taf::JceCurrentPtr current) = 0;
        static void async_response_getConfInfo(taf::JceCurrentPtr current, taf::Int32 _ret, const TConf::ConfRsp &rsp);

        virtual taf::Int32 getConfFileList(const TConf::ConfReq & req,vector<std::string> &vf,taf::JceCurrentPtr current) = 0;
        static void async_response_getConfFileList(taf::JceCurrentPtr current, taf::Int32 _ret, const vector<std::string> &vf);

        virtual taf::Int32 getPublicConf(const TConf::PublicConfReq & req,TConf::PublicConfRsp &rsp,taf::JceCurrentPtr current) = 0;
        static void async_response_getPublicConf(taf::JceCurrentPtr current, taf::Int32 _ret, const TConf::PublicConfRsp &rsp);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };

    inline taf::Int32 ConfigCenterProxy::getConfFileList(const TConf::ConfReq &req, vector<std::string> &vf, const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        _os.write(vf, 2);
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"getConfFileList", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(vf, 2, true);
        return _ret;
    }

    inline void ConfigCenter::async_response_getConfFileList(taf::JceCurrentPtr current, taf::Int32 _ret, const vector<std::string> &vf)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("vf", vf);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(vf, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    inline void ConfigCenterProxy::async_getConfFileList(ConfigCenterPrxCallbackPtr callback,const TConf::ConfReq &req,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getConfFileList", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    inline promise::Future< ConfigCenterPrxCallbackPromise::PromisegetConfFileListPtr > ConfigCenterProxy::promise_async_getConfFileList(const TConf::ConfReq &req,const map<string, string>& context)
    {
        promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetConfFileListPtr > promise;
        ConfigCenterPrxCallbackPromisePtr callback = new ConfigCenterPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getConfFileList", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    inline void ConfigCenterProxy::coro_getConfFileList(ConfigCenterCoroPrxCallbackPtr callback,const TConf::ConfReq &req,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getConfFileList", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    inline taf::Int32 ConfigCenterProxy::getConfInfo(const TConf::ConfReq &req, TConf::ConfRsp &rsp, const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        _os.write(rsp, 2);
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"getConfInfo", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(rsp, 2, true);
        return _ret;
    }

    inline void ConfigCenter::async_response_getConfInfo(taf::JceCurrentPtr current, taf::Int32 _ret, const TConf::ConfRsp &rsp)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("rsp", rsp);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(rsp, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    inline void ConfigCenterProxy::async_getConfInfo(ConfigCenterPrxCallbackPtr callback,const TConf::ConfReq &req,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getConfInfo", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    inline promise::Future< ConfigCenterPrxCallbackPromise::PromisegetConfInfoPtr > ConfigCenterProxy::promise_async_getConfInfo(const TConf::ConfReq &req,const map<string, string>& context)
    {
        promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetConfInfoPtr > promise;
        ConfigCenterPrxCallbackPromisePtr callback = new ConfigCenterPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getConfInfo", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    inline void ConfigCenterProxy::coro_getConfInfo(ConfigCenterCoroPrxCallbackPtr callback,const TConf::ConfReq &req,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getConfInfo", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    inline taf::Int32 ConfigCenterProxy::getPublicConf(const TConf::PublicConfReq &req, TConf::PublicConfRsp &rsp, const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        _os.write(rsp, 2);
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"getPublicConf", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(rsp, 2, true);
        return _ret;
    }

    inline void ConfigCenter::async_response_getPublicConf(taf::JceCurrentPtr current, taf::Int32 _ret, const TConf::PublicConfRsp &rsp)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("rsp", rsp);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(rsp, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    inline void ConfigCenterProxy::async_getPublicConf(ConfigCenterPrxCallbackPtr callback,const TConf::PublicConfReq &req,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getPublicConf", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    inline promise::Future< ConfigCenterPrxCallbackPromise::PromisegetPublicConfPtr > ConfigCenterProxy::promise_async_getPublicConf(const TConf::PublicConfReq &req,const map<string, string>& context)
    {
        promise::Promise< ConfigCenterPrxCallbackPromise::PromisegetPublicConfPtr > promise;
        ConfigCenterPrxCallbackPromisePtr callback = new ConfigCenterPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getPublicConf", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    inline void ConfigCenterProxy::coro_getPublicConf(ConfigCenterCoroPrxCallbackPtr callback,const TConf::PublicConfReq &req,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(req, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getPublicConf", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    inline ConfigCenterProxy* ConfigCenterProxy::taf_hash(int64_t key)
    {
        return (ConfigCenterProxy*)ServantProxy::taf_hash(key);
    }

    inline ConfigCenterProxy* ConfigCenterProxy::taf_consistent_hash(int64_t key)
    {
        return (ConfigCenterProxy*)ServantProxy::taf_consistent_hash(key);
    }

    inline ConfigCenterProxy* ConfigCenterProxy::taf_set_timeout(int msecond)
    {
        return (ConfigCenterProxy*)ServantProxy::taf_set_timeout(msecond);
    }

    inline ConfigCenterProxy* ConfigCenterProxy::taf_loaded()
    {
        return (ConfigCenterProxy*)ServantProxy::taf_loaded();
    }

    static ::std::string __TConf__ConfigCenter_all[]=
    {
        "getConfFileList",
        "getConfInfo",
        "getPublicConf"
    };

    inline const map<std::string, std::string> & ConfigCenterPrxCallback::getResponseContext() const
    {
        CallbackThreadData * pCbtd = CallbackThreadData::getData();
        assert(pCbtd != NULL);

        if(!pCbtd->getContextValid())
        {
            throw TC_Exception("cann't get response context");
        }
        return pCbtd->getResponseContext();
    }

    inline int ConfigCenterPrxCallback::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__TConf__ConfigCenter_all, __TConf__ConfigCenter_all+3, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TConf__ConfigCenter_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getConfFileList_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                vector<std::string> vf;
                _is.read(vf, 2, true);
                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_getConfFileList(_ret, vf);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getConfInfo_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                TConf::ConfRsp rsp;
                _is.read(rsp, 2, true);
                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_getConfInfo(_ret, rsp);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getPublicConf_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                TConf::PublicConfRsp rsp;
                _is.read(rsp, 2, true);
                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_getPublicConf(_ret, rsp);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    inline int ConfigCenterPrxCallbackPromise::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__TConf__ConfigCenter_all, __TConf__ConfigCenter_all+3, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TConf__ConfigCenter_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getConfFileList_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                ConfigCenterPrxCallbackPromise::PromisegetConfFileListPtr ptr = new ConfigCenterPrxCallbackPromise::PromisegetConfFileList();

                _is.read(ptr->_ret, 0, true);

                _is.read(ptr->vf, 2, true);

                ptr->_mRspContext = msg->response.context;

                callback_getConfFileList(ptr);

                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getConfInfo_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                ConfigCenterPrxCallbackPromise::PromisegetConfInfoPtr ptr = new ConfigCenterPrxCallbackPromise::PromisegetConfInfo();

                _is.read(ptr->_ret, 0, true);

                _is.read(ptr->rsp, 2, true);

                ptr->_mRspContext = msg->response.context;

                callback_getConfInfo(ptr);

                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getPublicConf_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                ConfigCenterPrxCallbackPromise::PromisegetPublicConfPtr ptr = new ConfigCenterPrxCallbackPromise::PromisegetPublicConf();

                _is.read(ptr->_ret, 0, true);

                _is.read(ptr->rsp, 2, true);

                ptr->_mRspContext = msg->response.context;

                callback_getPublicConf(ptr);

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    inline int ConfigCenterCoroPrxCallback::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__TConf__ConfigCenter_all, __TConf__ConfigCenter_all+3, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TConf__ConfigCenter_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getConfFileList_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                vector<std::string> vf;
                _is.read(vf, 2, true);
                setResponseContext(msg->response.context);

                callback_getConfFileList(_ret, vf);

                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getConfInfo_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                TConf::ConfRsp rsp;
                _is.read(rsp, 2, true);
                setResponseContext(msg->response.context);

                callback_getConfInfo(_ret, rsp);

                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getPublicConf_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                TConf::PublicConfRsp rsp;
                _is.read(rsp, 2, true);
                setResponseContext(msg->response.context);

                callback_getPublicConf(_ret, rsp);

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    inline int ConfigCenter::onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer)
    {
        pair<string*, string*> r = equal_range(__TConf__ConfigCenter_all, __TConf__ConfigCenter_all+3, _current->getFuncName());
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TConf__ConfigCenter_all)
        {
            case 0:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                TConf::ConfReq req;
                vector<std::string> vf;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("req", req);
                    tafAttr.getByDefault("vf", vf, vf);
                }
                else
                {
                    _is.read(req, 1, true);
                    _is.read(vf, 2, false);
                }
                taf::Int32 _ret = getConfFileList(req,vf, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("vf", vf);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(vf, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                TConf::ConfReq req;
                TConf::ConfRsp rsp;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("req", req);
                    tafAttr.getByDefault("rsp", rsp, rsp);
                }
                else
                {
                    _is.read(req, 1, true);
                    _is.read(rsp, 2, false);
                }
                taf::Int32 _ret = getConfInfo(req,rsp, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("rsp", rsp);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(rsp, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                TConf::PublicConfReq req;
                TConf::PublicConfRsp rsp;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("req", req);
                    tafAttr.getByDefault("rsp", rsp, rsp);
                }
                else
                {
                    _is.read(req, 1, true);
                    _is.read(rsp, 2, false);
                }
                taf::Int32 _ret = getPublicConf(req,rsp, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("rsp", rsp);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(rsp, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

} // end namespace TConf

#define TConf_ConfReqListInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.configType,b.configType);jce_copy_struct(a.fileName,b.fileName);jce_copy_struct(a.md5,b.md5);

#define TConf_ConfReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.appid,b.appid);jce_copy_struct(a.ns,b.ns);jce_copy_struct(a.host,b.host);jce_copy_struct(a.setname,b.setname);jce_copy_struct(a.containername,b.containername);jce_copy_struct(a.vConfInfoList,b.vConfInfoList);jce_copy_struct(a.apiVersion,b.apiVersion);

#define TConf_ConfRspInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.configType,b.configType);jce_copy_struct(a.fileName,b.fileName);jce_copy_struct(a.fileContent,b.fileContent);jce_copy_struct(a.md5,b.md5);jce_copy_struct(a.updated,b.updated);

#define TConf_ConfRsp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.appid,b.appid);jce_copy_struct(a.vConfInfoList,b.vConfInfoList);jce_copy_struct(a.refreshInterval,b.refreshInterval);

#define TConf_PublicConfReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ns,b.ns);jce_copy_struct(a.setname,b.setname);jce_copy_struct(a.vConfInfoList,b.vConfInfoList);jce_copy_struct(a.apiVersion,b.apiVersion);

#define TConf_PublicConfRsp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ns,b.ns);jce_copy_struct(a.vConfInfoList,b.vConfInfoList);


#endif

